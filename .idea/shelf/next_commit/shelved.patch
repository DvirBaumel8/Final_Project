Index: src/main/java/ProjectScanning/BlackListUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/ProjectScanning/BlackListUtil.java	(date 1590081718571)
+++ src/main/java/ProjectScanning/BlackListUtil.java	(date 1590081718571)
@@ -0,0 +1,98 @@
+package ProjectScanning;
+
+import java.io.File;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.List;
+
+public class BlackListUtil {
+    private File blackListFile;
+    private String resourcesDirPath;
+    private static List<String> blackListInstances;
+
+    public BlackListUtil(String resourcesDirPath) {
+        this.resourcesDirPath = resourcesDirPath;
+        blackListFile = new File(resourcesDirPath);
+    }
+
+    public static List<String> getBlackListInstances() {
+        if(blackListInstances == null) {
+            return null;
+        }
+        else {
+            return blackListInstances;
+        }
+    }
+
+    public void parseBlackListFile() {
+        List<String> blacklistFileLines = null;
+        try {
+            blacklistFileLines= Files.readAllLines(blackListFile.toPath(), StandardCharsets.UTF_8);
+        }
+        catch(Exception e) {
+            //
+        }
+
+        for(int i = 1; i < blacklistFileLines.size(); i++) {
+            blackListInstances.add(blacklistFileLines.get(i));
+        }
+    }
+
+    public boolean isBlackListFileExist() {
+        File[] files = blackListFile.listFiles();
+        File currFile;
+
+        for(int i = 0; i < files.length; i++) {
+            currFile = files[i];
+            if(currFile.isDirectory()) {
+                return isBlackListFileExist(currFile);
+            }
+            else {
+                if(currFile.getName().equals("BlackList")) {
+                    blackListFile = currFile;
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public boolean isBlackListFileExist(File rootDir) {
+        File[] files = blackListFile.listFiles();
+        File currFile;
+
+        for(int i = 0; i < files.length; i++) {
+            currFile = files[i];
+            if(currFile.isDirectory()) {
+                isBlackListFileExist(currFile);
+            }
+            else {
+                if(currFile.getName().equals("BlackList")) {
+                    blackListFile = currFile;
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public boolean needEnforceBlackList() {
+        List<String> blacklistFileLines = null;
+        try {
+            blacklistFileLines= Files.readAllLines(blackListFile.toPath(), StandardCharsets.UTF_8);
+        }
+        catch(Exception e) {
+            //
+        }
+        String firstLine = blacklistFileLines.get(0);
+        if(firstLine.equals("BlackList=true")) {
+            blackListInstances = new ArrayList<>();
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+}
Index: src/main/java/FilesUtil/FilesUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package FilesUtil;\n\nimport Manager.Manager;\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\n\npublic class FilesUtil {\n    private static final String POM_FILE = \"pom.xml\";\n    private static final String MAIN_METHOD = \"public static void main(String[] args) {\";\n    private static final String APP_CONTEXT = \"ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class);\";\n    private static final String SPRING_IMPORT = \"import org.springframework.context.ApplicationContext;\\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\";\n    private static final String MAIN = \"Main.java\";\n\n    public File[] getProjectFiles(String directoryPath) {\n        try {\n            File directory = new File(directoryPath);\n            File[] content = directory.listFiles();\n            if(validateProject(content)) {\n                return content;\n            }\n            else {\n                //throw new exception\n            }\n            return content;\n        }\n        catch(Exception e) {\n\n        }\n        return null;\n    }\n\n    private boolean validateProject(File[] content) {\n        return true;\n    }\n\n    public void addSpringDependenciesToPomFile(File[] projectFile) throws IOException {\n        File pomFile = findFileByName(projectFile, POM_FILE);\n        addSpringDependenciesToPomFile(pomFile);\n    }\n\n    private void addSpringDependenciesToPomFile(File pomFile) throws IOException {\n        List<String> lines = Files.readAllLines(pomFile.toPath(), StandardCharsets.UTF_8);\n        PrintStream out = new PrintStream(new FileOutputStream(pomFile));\n\n        int index = 0;\n\n\n        if(checkIfPomContentContainsDependenciesOpen(lines)) {\n            for(String line : lines) {\n                index++;\n                if(line.contains(\"<dependencies>\")) {\n                    break;\n                }\n\n            }\n            lines.add(index, getDependenciesStrWithOutOpen());\n\n        }\n        else {\n            for(String line : lines) {\n                index++;\n                if(line.contains(\"<version>\")) {\n                    break;\n                }\n\n            }\n            lines.add(index, getDependenciesStrWithOpen());\n        }\n\n        StringBuilder newContent = new StringBuilder();\n        for(String line : lines) {\n            newContent.append(line);\n            newContent.append(System.lineSeparator());\n        }\n        out.write(newContent.toString().getBytes());\n    }\n\n    private boolean checkIfPomContentContainsDependenciesOpen(List<String> lines) {\n\n        for(String line : lines) {\n            if(line.contains(\"<dependencies>\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //Maybe we have to delete\n    public File findFileByName(File[] projectFiles, String fileName) {\n        File main;\n        for(int i = 0; i < projectFiles.length; i++) {\n            if(projectFiles[i].listFiles() != null ) {\n                  main = findFileByName(projectFiles[i].listFiles(), fileName);\n                  if(main != null) {\n                      return main;\n                  }\n            }\n            if(projectFiles[i].getName().equals(fileName)) {\n                return projectFiles[i];\n            }\n\n        }\n        return null;\n    }\n\n    private String getDependenciesStrWithOpen() {\n        return \"    <dependencies>\\n\" +\n                \"    <!--spring core-->\\n\" +\n                \"    <dependency>\\n\" +\n                \"        <groupId>org.springframework</groupId>\\n\" +\n                \"        <artifactId>spring-context</artifactId>\\n\" +\n                \"        <version>5.0.6.RELEASE</version>\\n\" +\n                \"    </dependency>\\n\" +\n                \"    </dependencies>\";\n    }\n\n    private String getDependenciesStrWithOutOpen() {\n        return \"    <dependency>\\n\" +\n                \"        <groupId>org.springframework</groupId>\\n\" +\n                \"        <artifactId>spring-context</artifactId>\\n\" +\n                \"        <version>5.0.6.RELEASE</version>\\n\" +\n                \"    </dependency>\";\n    }\n\n\n    public String createNewSpringProjectDirectory(String projectPath) throws IOException {\n        String[] elements = projectPath.split(\"/\");\n        StringBuilder pathOfNewSpringProject = new StringBuilder();\n        String separator = \"/\";\n        pathOfNewSpringProject.append(separator);\n\n        for(int i = 1; i < elements.length - 1; i++) {\n            pathOfNewSpringProject.append(elements[i] + separator);\n        }\n\n        return createNewFolderInSpecificPath(pathOfNewSpringProject.toString(), elements[elements.length - 1]);\n    }\n\n    private String createNewFolderInSpecificPath(String pathOfNewSpringProject, String directoryName) throws IOException {\n        pathOfNewSpringProject = pathOfNewSpringProject + directoryName + \"_Spring_Way\";\n        Path path = Paths.get(pathOfNewSpringProject);\n        if(Files.exists(path)) {\n            FileUtils.cleanDirectory(new File(pathOfNewSpringProject));\n        }\n        else {\n            Files.createDirectory(path);\n        }\n        return pathOfNewSpringProject;\n    }\n\n    public void addAnnotationContextToMain(File[] editProjectFiles) throws IOException {\n        File mainFile = findFileByName(editProjectFiles, MAIN);\n        List<String> allLines = Files.readAllLines(mainFile.toPath(), StandardCharsets.UTF_8);\n        PrintStream out = new PrintStream(new FileOutputStream(mainFile));\n        int index = 0;\n\n        for(String line : allLines) {\n            if(line.contains(\"package\")) {\n                index++;\n            }\n        }\n\n        allLines.add(index, SPRING_IMPORT);\n        index = 0;\n\n        for(String line : allLines) {\n            if(line.contains(MAIN_METHOD)) {\n                index++;\n                break;\n            }\n            index++;\n        }\n        allLines.add(index, APP_CONTEXT);\n\n        StringBuilder newContent = new StringBuilder();\n        for(String line : allLines) {\n            newContent.append(line);\n            newContent.append(System.lineSeparator());\n        }\n        out.write(newContent.toString().getBytes());\n    }\n\n    public void populateConfigMainFile(File confFile) throws IOException {\n        PrintStream out = new PrintStream(new FileOutputStream(confFile));\n        String mainConfFileStr = getMainConfString();\n        out.write(mainConfFileStr.getBytes());\n    }\n\n    private String getMainConfString() {\n        return \"import org.springframework.context.annotation.Configuration;\\n\" +\n                \"\\n\" +\n                \"@Configuration\\n\" +\n                \"public class MainConfiguration {\\n\" +\n                \"    \\n\" +\n                \"}\";\n    }\n\n    public void addMainConfFile() throws IOException {\n       String createPath = Manager.getInstance().getJavaDirectory().getPath() + \"/MainConfiguration.java\";\n        File confFile = new File(createPath);\n        populateConfigMainFile(confFile);\n    }\n\n    public void copyPasteSourceToEdit(File[] sourceProjectFiles, String path) {\n        for(int i =0; i < sourceProjectFiles.length; i++) {\n            copyPasteFile(sourceProjectFiles[i], path + \"/\" + sourceProjectFiles[i].getName());\n        }\n    }\n\n    private void copyPasteFile(File sourceProjectFile, String s) {\n        Path path = Paths.get(s);\n        File editFile;\n\n        try {\n            if(sourceProjectFile.isDirectory()) {\n                Files.createDirectory(path);\n                editFile = new File(s);\n                Manager.getInstance().addFileToEditProject(editFile);\n                FileUtils.copyDirectory(sourceProjectFile, editFile);\n            }\n            else {\n                editFile = new File(s);\n                Manager.getInstance().addFileToEditProject(editFile);\n                FileUtils.copyFile(sourceProjectFile, editFile);\n            }\n        }\n        catch (Exception e) {\n            System.out.println();\n        }\n    }\n\n    public File getJavaDirectory(File[] projectFiles) {\n        File main = null;\n        File src = null;\n\n        try {\n            src = getSrcDir(projectFiles);\n            main = getMainDir(src);\n            return getJavaDir(main);\n        }\n        catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n\n        return null;\n    }\n\n    public static File getSrcDir(File[] projectFiles) throws Exception {\n        for(int i =0; i < projectFiles.length; i++) {\n            if(projectFiles[i].getName().equals(\"src\")) {\n                return projectFiles[i];\n            }\n        }\n        throw new Exception(\"src directory did not found, sorry\");\n    }\n\n    public File getMainDir(File srcFile) throws Exception {\n        File[] files = srcFile.listFiles();\n\n        for(int i =0; i < files.length; i++) {\n            if(files[i].getName().equals(\"main\")) {\n                return files[i];\n            }\n        }\n        throw new Exception(\"main directory did not found, sorry\");\n    }\n\n    public File getJavaDir(File mainFile) throws Exception {\n        File[] files = mainFile.listFiles();\n\n        for(int i =0; i < files.length; i++) {\n            if(files[i].getName().equals(\"java\")) {\n                return files[i];\n            }\n        }\n        throw new Exception(\"java directory did not found, sorry\");\n    }\n\n    public static File getTestDir(File srcFile) throws Exception {\n        File[] files = srcFile.listFiles();\n\n        for(int i =0; i < files.length; i++) {\n            if(files[i].getName().equals(\"test\")) {\n                return files[i];\n            }\n        }\n        throw new Exception(\"test directory did not found, sorry\");\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/FilesUtil/FilesUtil.java	(revision 43eaca1bcb2156c1282ee1a18a2c15d7ec647925)
+++ src/main/java/FilesUtil/FilesUtil.java	(date 1590937087095)
@@ -132,17 +132,11 @@
     }
 
 
-    public String createNewSpringProjectDirectory(String projectPath) throws IOException {
-        String[] elements = projectPath.split("/");
+    public String createNewSpringProjectDirectory(String projectPathString) throws IOException {
+        Path projectPath = Paths.get(projectPathString);
         StringBuilder pathOfNewSpringProject = new StringBuilder();
-        String separator = "/";
-        pathOfNewSpringProject.append(separator);
-
-        for(int i = 1; i < elements.length - 1; i++) {
-            pathOfNewSpringProject.append(elements[i] + separator);
-        }
-
-        return createNewFolderInSpecificPath(pathOfNewSpringProject.toString(), elements[elements.length - 1]);
+        pathOfNewSpringProject.append(File.separator + projectPath.getParent() + File.separator);
+        return createNewFolderInSpecificPath(pathOfNewSpringProject.toString(), projectPath.getFileName().toString());
     }
 
     private String createNewFolderInSpecificPath(String pathOfNewSpringProject, String directoryName) throws IOException {
Index: src/main/java/Manager/Manager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Manager;\n\nimport FilesUtil.FilesUtil;\nimport ProjectContainers.EditProject;\nimport ProjectContainers.SourceProject;\nimport ProjectScanning.Scanner;\nimport UnitTests.UnitTestValidator;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Manager {\n    private static Manager manager;\n    private FilesUtil filesUtil;\n    private SourceProject sourceProject;\n    private EditProject editProject;\n    private UnitTestValidator unitTestValidator;\n\n\n    public static Manager getInstance() {\n        if(manager == null) {\n            manager = new Manager();\n        }\n        return manager;\n    }\n\n    private Manager() {\n        filesUtil = new FilesUtil();\n    }\n\n    public void start(String projectPath) throws IOException {\n        init(projectPath);\n        scanProject();\n        unitTestValidator.runUnitTests(editProject.getEditProjectFiles());\n    }\n\n    private void scanProject() throws IOException {\n        Scanner scanner = new Scanner();\n        scanner.scan(filesUtil.getJavaDirectory(editProject.getEditProjectFiles()).getPath());\n    }\n\n    private void init(String projectPath) throws IOException {\n        unitTestValidator = new UnitTestValidator();\n        editProject = new EditProject();\n        sourceProject = new SourceProject();\n        sourceProject.setProjectPath(projectPath);\n        setValueToProjectName();\n        editProject.setPath(filesUtil.createNewSpringProjectDirectory(projectPath));\n        sourceProject.setProjectFiles(filesUtil.getProjectFiles(projectPath));\n        copyPasteSourceToEdit();\n        initializeEditProjectToSpring();\n    }\n\n    private void initializeEditProjectToSpring() throws IOException {\n        filesUtil.addSpringDependenciesToPomFile(editProject.getEditProjectFiles());\n        filesUtil.addMainConfFile();\n    }\n\n    private void copyPasteSourceToEdit()  {\n        editProject.initFilesArr(sourceProject.getProjectFiles().length);\n        filesUtil.copyPasteSourceToEdit(sourceProject.getProjectFiles(), editProject.getPath());\n    }\n\n    public File getJavaDirectory() {\n        return filesUtil.getJavaDirectory(editProject.getEditProjectFiles());\n    }\n\n    private void setValueToProjectName( ) {\n        String[] elements = sourceProject.getProjectPath().split(\"/\");\n        sourceProject.setProjectName(elements[elements.length - 1]);\n    }\n\n    public boolean validateProjectDirectoryPath(String projectDirectoryPath) {\n        boolean isValid = true;\n\n        if(!validateDirectoryContainPomFile(projectDirectoryPath)) {\n            isValid = false;\n        }\n        if(!Files.exists(Paths.get(projectDirectoryPath))) {\n            isValid = false;\n        }\n        return isValid;\n    }\n\n    private boolean validateDirectoryContainPomFile(String projectDirectoryPath) {\n        return true;\n    }\n\n    public String getProjectPathErrorMessage() {\n        return null;\n    }\n\n    public void addFileToEditProject(File editFile) {\n        editProject.addFile(editFile);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/Manager/Manager.java	(revision 43eaca1bcb2156c1282ee1a18a2c15d7ec647925)
+++ src/main/java/Manager/Manager.java	(date 1590419188110)
@@ -18,7 +18,6 @@
     private EditProject editProject;
     private UnitTestValidator unitTestValidator;
 
-
     public static Manager getInstance() {
         if(manager == null) {
             manager = new Manager();
Index: src/main/java/ProjectScanning/Scanner.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ProjectScanning;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class Scanner {\n    private Map<String, String> classNameToPath;\n    private Map<String, NewBeanDetails> instanceNameToBeanDetails;\n    private boolean isBeanAdded;\n    private Set<String> classesToAddAppCox;\n\n    public Scanner() {\n        classNameToPath = new HashMap<>();\n        instanceNameToBeanDetails = new HashMap<>();\n        classesToAddAppCox = new HashSet<>();\n        isBeanAdded = false;\n    }\n\n    public void scan(String javaDir) throws IOException {\n        findClasses(javaDir);\n        findNewProjectInstancesCreation();\n        createBeanMethods();\n        handleAppCtxWriteToNeededClasses();\n    }\n\n    private void handleAppCtxWriteToNeededClasses() throws IOException {\n        for(Map.Entry<String, String> entry : classNameToPath.entrySet()) {\n            for(String clazz : classesToAddAppCox) {\n                if(clazz.equals(entry.getKey())) {\n                    addAppCtxToClass(clazz, entry.getValue());\n                }\n            }\n        }\n    }\n\n    private void addAppCtxToClass(String clazz, String classPath) throws IOException {\n        File file = new File(classPath);\n        List<String> lines = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8);\n        int index = 0;\n\n        for(String line : lines) {\n            if(line.contains(String.format(\"class %s\", clazz))) {\n                index++;\n                break;\n            }\n            index++;\n        }\n        lines.add(index, \"   private static ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class);\");\n        index -= 2;\n        lines.add(index, \"import org.springframework.context.ApplicationContext;\\n\" +\n                \"import org.springframework.context.annotation.AnnotationConfigApplicationContext;\");\n        writeNewContentToFile(file, lines);\n    }\n\n    private void createBeanMethods() throws IOException {\n        File mainConf = getMainConfigurationFile();\n        String cBeanMethodStr;\n\n        for(Map.Entry<String, NewBeanDetails> entry : instanceNameToBeanDetails.entrySet()) {\n            cBeanMethodStr = createBeanMethodStr(entry.getKey(), entry.getValue());\n            addMethodToFile(mainConf, cBeanMethodStr);\n        }\n    }\n\n    private void addMethodToFile(File mainConf, String cBeanMethodStr) throws IOException {\n        if(!isBeanAdded) {\n            addImportBeansToConf(mainConf);\n            isBeanAdded = true;\n        }\n        List<String> lines = Files.readAllLines(mainConf.toPath(), StandardCharsets.UTF_8);\n\n        int index = 0;\n\n        for(String line : lines) {\n            if(line.contains(\"@Configuration\")) {\n                index += 2;\n                break;\n            }\n            index++;\n        }\n        lines.add(index, cBeanMethodStr);\n        writeNewContentToFile(mainConf, lines);\n\n    }\n\n    private void writeNewContentToFile(File mainConf, List<String> lines) throws IOException {\n        PrintStream out = new PrintStream(new FileOutputStream(mainConf));\n        StringBuilder str = new StringBuilder();\n        for(String line : lines) {\n            str.append(line);\n            str.append(System.lineSeparator());\n        }\n        out.write(str.toString().getBytes());\n    }\n\n    private void addImportBeansToConf(File mainConf) throws IOException {\n        List<String> lines = Files.readAllLines(mainConf.toPath(), StandardCharsets.UTF_8);\n        int index = 0;\n        String beanImport = \"import org.springframework.context.annotation.Bean;\";\n\n        for(String line : lines) {\n            if(line.contains(\"Configuration\")) {\n                index++;\n                break;\n            }\n            else {\n                index++;\n            }\n        }\n        lines.add(index, beanImport);\n\n        writeNewContentToFile(mainConf, lines);\n    }\n\n    private String createBeanMethodStr(String instanceName, NewBeanDetails beanDetails) throws IOException {\n        String origClass = beanDetails.getOrigClass();\n        StringBuilder str = new StringBuilder();\n        str.append(\"@Bean\\n\");\n        str.append(String.format(\"public %s %s() {\\n\", origClass, instanceName));\n        String constructorArgs = beanDetails.getCreationObjectConstructorArgs();\n        str.append(String.format(\"%s %s = new %s(%s);\\n\", origClass, instanceName, origClass, constructorArgs));\n        String settersStr = getSettersStrs(beanDetails);\n        str.append(settersStr);\n        str.append(String.format(\"return %s;\\n}\\n\", instanceName));\n\n        return str.toString();\n    }\n\n    private String getSettersStrs(NewBeanDetails beanDetails) throws IOException {\n        File file = null;\n        String createdUnderClass = beanDetails.getCreatedUnderClass();\n        for(Map.Entry<String, String> entry : classNameToPath.entrySet()) {\n            if(createdUnderClass.equals(entry.getKey())) {\n                file = new File(entry.getValue());\n                break;\n            }\n        }\n\n        return getSettersStrs(file, beanDetails.getBeanName());\n    }\n\n    private String getSettersStrs(File file, String beanName) throws IOException {\n        List<String> lines = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8);\n        StringBuilder str = new StringBuilder();\n        List<String> linesToRemove = new ArrayList<>();\n\n        for(String line : lines) {\n            if(line.contains(beanName + \".set\")) {\n                if(!line.contains(\"new\")) {\n                    str.append(line);\n                    str.append(System.lineSeparator());\n                    linesToRemove.add(line);\n                }\n            }\n        }\n\n        for(String line : linesToRemove) {\n            lines.remove(line);\n        }\n        writeNewContentToFile(file, lines);\n\n        return str.toString();\n    }\n\n\n    private File getMainConfigurationFile() {\n        String mainConfPath = null;\n        for(Map.Entry<String, String> entry : classNameToPath.entrySet()) {\n            if(entry.getKey().equals(\"MainConfiguration\")) {\n                mainConfPath = entry.getValue();\n                break;\n            }\n        }\n        return new File(mainConfPath);\n    }\n\n    private void findNewProjectInstancesCreation() throws IOException {\n\n        for (Map.Entry<String, String> entry : classNameToPath.entrySet()) {\n            if (entry.getKey().equals(\"MainConfiguration\")) {\n                continue;\n            }\n            handleInternalClassScan(entry.getValue(), entry.getKey());\n        }\n    }\n\n    private void handleInternalClassScan(String classPath, String key) throws IOException {\n        String[] elements;\n        String className;\n        String instanceName;\n        Map<String, String> replaceLineWithNew = new HashMap<>();\n        File cFile = new File(classPath);\n        List<String> allLines = Files.readAllLines(cFile.toPath(), StandardCharsets.UTF_8);\n        int index = 0;\n\n        for(String line : allLines) {\n            if(line.contains(\"new\")) {\n                elements = line.split(\" \");\n                className = findClassName(elements);\n                if(checkIfClassIsInternal(className)) {\n                    instanceName = findInstanceName(elements);\n                    NewBeanDetails beanDetails = new NewBeanDetails(key, line, instanceName, className);;\n                    classesToAddAppCox.add(key);\n                    if(instanceNameToBeanDetails.containsKey(instanceName)) {\n                        String beanName = BeanNamesGenerator.getNewBeanName();\n                        beanDetails = new NewBeanDetails(key, line, beanName, className);\n                        instanceNameToBeanDetails.put(beanName, beanDetails);\n                    }\n                    else {\n                        instanceNameToBeanDetails.put(instanceName, beanDetails);\n                    }\n                    replaceLineWithNew.put(line, getBeanAccessStr(className, instanceName));\n                }\n            }\n            index++;\n        }\n        for(Map.Entry<String, String> item : replaceLineWithNew.entrySet()) {\n            replaceLines(cFile, item.getKey(), item.getValue(), allLines);\n        }\n        writeNewContentToFile(cFile, allLines);\n    }\n\n    private void replaceLines(File cFile, String lineToRemove, String lineToWrite, List<String> allLines) {\n        int index = 0;\n\n        for(String line : allLines) {\n            if(line.equals(lineToRemove)) {\n                allLines.remove(lineToRemove);\n                break;\n            }\n            index++;\n        }\n        allLines.add(index, lineToWrite);\n    }\n\n    private String getBeanAccessStr(String className, String instanceName) {\n        return String.format(\"      %s %s = context.getBean(\\\"%s\\\", %s.class);\", className, instanceName, instanceName, className);\n\n    }\n\n    private String findInstanceName(String[] elements) {\n        int index = 0;\n        for(int i = 0; i < elements.length; i++) {\n            if(elements[i].equals(\"\")) {\n                index++;\n            }\n            else {\n                index++;\n                break;\n            }\n        }\n        return elements[index];\n    }\n\n    private String findClassName(String[] elements) {\n            for(int i = 0; i < elements.length; i++) {\n                if(elements[i].equals(\"new\")) {\n                    i++;\n                    return elements[i].split(String.format(\"\\\\(\"))[0];\n                }\n            }\n            return null;\n    }\n\n    private boolean checkIfClassIsInternal(String instanceName) {\n        for(Map.Entry<String, String> entry : classNameToPath.entrySet()) {\n            if(entry.getKey().equals(instanceName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void findClasses(String javaDir) throws IOException {\n        File file = new File(javaDir);\n        File[] files = file.listFiles();\n        File currFile;\n\n        for(int i = 0; i < files.length; i++) {\n            currFile = files[i];\n            if(currFile.isDirectory()) {\n                findClasses(currFile.getPath());\n            }\n            else {\n                if(scanClass(currFile)) {\n                    classNameToPath.put(getDisplayClassName(currFile.getName()), currFile.getPath());\n                }\n            }\n        }\n    }\n\n    private String getDisplayClassName(String name) {\n        String[] names = name.split(\"\\\\.\");\n        return names[0];\n    }\n\n\n    private boolean scanClass(File currFile) throws IOException {\n        if(!currFile.getName().endsWith(\".java\")) {\n            return false;\n        }\n        else {\n            List<String> allLines = Files.readAllLines(currFile.toPath(), StandardCharsets.UTF_8);\n            for(String line : allLines) {\n                if(line.contains(\"public class\")) {\n                    return true;\n                }\n\n            }\n            return false;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/ProjectScanning/Scanner.java	(revision 43eaca1bcb2156c1282ee1a18a2c15d7ec647925)
+++ src/main/java/ProjectScanning/Scanner.java	(date 1590420886746)
@@ -19,21 +19,52 @@
     private Map<String, NewBeanDetails> instanceNameToBeanDetails;
     private boolean isBeanAdded;
     private Set<String> classesToAddAppCox;
+    private List<String> blackListInstances;
+    private boolean isProjectBlackListing;
+
 
     public Scanner() {
         classNameToPath = new HashMap<>();
         instanceNameToBeanDetails = new HashMap<>();
         classesToAddAppCox = new HashSet<>();
         isBeanAdded = false;
+        blackListInstances = new ArrayList<>();
+        isProjectBlackListing = false;
     }
 
     public void scan(String javaDir) throws IOException {
+        BlackListUtil blackListUtil = new BlackListUtil(getResourcesPathFromJavaPath(javaDir));
+        if(blackListUtil.isBlackListFileExist()) {
+            if(blackListUtil.needEnforceBlackList()) {
+                blackListUtil.parseBlackListFile();
+                isProjectBlackListing = true;
+            }
+        }
+        blackListInstances = BlackListUtil.getBlackListInstances();
+
         findClasses(javaDir);
         findNewProjectInstancesCreation();
         createBeanMethods();
         handleAppCtxWriteToNeededClasses();
     }
 
+    private String getResourcesPathFromJavaPath(String javaDir) {
+        String[] elements = javaDir.split("/");
+        elements[elements.length - 1] = "resources";
+        StringBuilder str = new StringBuilder();
+        for(int i = 0; i < elements.length; i++) {
+            if(i == elements.length - 1) {
+                str.append(elements[i]);
+                break;
+            }
+            else {
+                str.append(elements[i]);
+                str.append("/");
+            }
+        }
+        return str.toString();
+    }
+
     private void handleAppCtxWriteToNeededClasses() throws IOException {
         for(Map.Entry<String, String> entry : classNameToPath.entrySet()) {
             for(String clazz : classesToAddAppCox) {
@@ -208,19 +239,30 @@
             if(line.contains("new")) {
                 elements = line.split(" ");
                 className = findClassName(elements);
-                if(checkIfClassIsInternal(className)) {
-                    instanceName = findInstanceName(elements);
-                    NewBeanDetails beanDetails = new NewBeanDetails(key, line, instanceName, className);;
-                    classesToAddAppCox.add(key);
-                    if(instanceNameToBeanDetails.containsKey(instanceName)) {
-                        String beanName = BeanNamesGenerator.getNewBeanName();
-                        beanDetails = new NewBeanDetails(key, line, beanName, className);
-                        instanceNameToBeanDetails.put(beanName, beanDetails);
-                    }
-                    else {
-                        instanceNameToBeanDetails.put(instanceName, beanDetails);
-                    }
-                    replaceLineWithNew.put(line, getBeanAccessStr(className, instanceName));
+                instanceName = findInstanceName(elements);
+                if(isProjectBlackListing) {
+                    if(verifyInstanceIsNotBlackListed(instanceName)) {
+                        if(checkIfClassIsInternal(className)) {
+                            NewBeanDetails beanDetails = new NewBeanDetails(key, line, instanceName, className);;
+                            classesToAddAppCox.add(key);
+                            if(checkIfClassIsInternal(className)) {
+                                instanceName = findInstanceName(elements);
+                                instanceNameToBeanDetails.put(instanceName, beanDetails);
+                                replaceLineWithNew.put(line, getBeanAccessStr(className, instanceName));
+                            }
+                        }
+                    }
+                }
+                else {
+                    if(checkIfClassIsInternal(className)) {
+                        NewBeanDetails beanDetails = new NewBeanDetails(key, line, instanceName, className);;
+                        classesToAddAppCox.add(key);
+                        if(checkIfClassIsInternal(className)) {
+                            instanceName = findInstanceName(elements);
+                            instanceNameToBeanDetails.put(instanceName, beanDetails);
+                            replaceLineWithNew.put(line, getBeanAccessStr(className, instanceName));
+                        }
+                    }
                 }
             }
             index++;
@@ -231,6 +273,20 @@
         writeNewContentToFile(cFile, allLines);
     }
 
+    private boolean verifyInstanceIsNotBlackListed(String instanceName) {
+        if(!isProjectBlackListing) {
+            return false;
+        }
+        else {
+            if(blackListInstances.contains(instanceName)) {
+                return false;
+            }
+            else {
+                return true;
+            }
+        }
+    }
+
     private void replaceLines(File cFile, String lineToRemove, String lineToWrite, List<String> allLines) {
         int index = 0;
 
